---
title: 《测试 Vue.js 应用》- Vue 应用单元测试介绍
category: code
tags:
- 前端
- 单元测试
- 翻译
- Vue.js
---

## 本章包含：

- 测试是什么
- 为什么测试是有效的
- 单元测试、端对端测试、快照测试的区别
- Vue 核心概念

<!-- more -->

作为一个开发者，你想写出没有 bug 的代码。没有什么事能比周一早上发现你运行的应用被周五的改动组织了正常运行更遭了！唯一确保你应用正确运行的方式是测试它，所以学习如何完整地测试应用是至关重要的。

一个好的测试方法能够加速开发，改善代码质量，限制应用中 bug 的数量。糟糕的测试方法会削弱一个项目。本书将会教你有效地测试 Vue 应用，使你收获测试的好处并避免一些坑。读完本书，你将成为 Vue 测试专家，能够测试任何你遇到的 Vue 应用。

为了学习 Vue 应用测试的技术，你需要从头到尾为 Hack New 写一套测试。Hack News 使用到了像大多数 Vue 大型应用的技术 Vue，Vuex，Vue Router 和服务端渲染。

除了教你这些技术，我也想教你我开发这些年来关于测试的经验与习惯。通过这本书我会给你建议来提升你的测试技巧。

本章是测试 Vue 应用的初级读物。我会教你一般的测试的大致概念，本书中你也会学会不同类型的测试。最后，我会解释一些 Vue 的核心概念，来确保你能明白这些专业术语。

第一件要做的事情就是定义测试。

## 测试的定义

所有合格的学术论文首先定义概念，然后才是深入讨论它们。所以，像一篇好的学术论文一样，在我教你不同的测试技术前，我会给出测试一个应用的定义。

一个简单的定义：测试一个应用是检查每个过程中应用的行为是否正确。由你自己来检查应用是否表现正确是不聪明的，但是如果讨论的是不同的测试技术，话题就会变得有趣起来。

有两种主要的方式来测试：人工测试和自动化测试。人工测试指的是由你自己来检查应用的正确性。自动化测试是写程序来替你完成的应用检查。

本书大部分内容讲述自动化测试。但是为了理解自动化测试的好处，你需要明白人工测试。

### 人工测试

每一个符合最低雇用要求的开发者人工地进行测试代码。它是写完源代码后的下一个合理的步骤，就像嚼完食物后的下一步是吞下它。

想象一下你在做一个注册表单。当你完成代码后，你不会关闭你的代码编辑器然后告诉你的老板你完成了。你会打开浏览器，填写表单，确保注册流程是正确的。换句话说，你在进行人工测试。

人工测试对于小项目来说是很棒的。如果你的应用是人工两分钟内完成测试的待办事项清单应用，你不需要自动化测试。但是当你的应用到了一定的规模，依赖人工测试是一种负担。

让我告诉你我的第一个大型 Javascript 应用。应用是非常混乱的。你听说过像意大利式细面条一样的代码吗？这代码就像是意大利式细面条、 意大利干面条、意大利扁面条的组合。遵循应用的逻辑十分困难，没有任何的自动化测试。不必多说，代码中充满了 bug。为了组织 bug，在发布应用前，我们人工测试了应用。每周三，我们会准备一些咖啡，打开用户操作列表（user journeys）来测试，按照指示在笔记本电脑前弯腰弓背测试四个小时。这是非常痛苦的。

::: tip 用户操作（user journeys）
用户操作指的是用户操作应用的一系列步骤。例如，打开应用，填写表单，点击提交。
:::

考虑到我们花了我们 10% 的开发时间来人工测试应用，我们就能没有 bug 的发布到生产环境了吗。不是的！应用里还是充满了 bug。理由是人工测试了上百种情况，但还是很容易忽略某些特定的情况，忘记去检查某些事情。

有一次我在遵循用户列表测试时，意外地发现了点击按钮时的一个问题。其他开发者一定也忽略了测试这个问题，因为这个 bug 已经存在了几个月了！

尽管我们人工测试的一些时间是花费在测试新特性上的，但大多数还是花费在了检测旧功能是不是还能使用上。这种测试称之为回归测试。回归测试是一项对于人来说困难的重复性的工作。简而言之，它们是枯燥的。幸运的是，计算机做这些任务是很快的，自动化测试从而到来了！

### 自动化测试

自动话测试是通过使用编码的方式来检测你的软件是否正常运行。换句话说，你得为你的应用写额外的代码。在测试代码写好后，你不必花多少力气来测试你的应用无论多少次。

你能够使用不同的技术来写自动化测试。你能够编码来自动化浏览器，直接调用你源码里的方法，或者对比渲染后的应用截屏。每一个测试方法都有不同的好处，但它们都有一些相同的好处：它们节省了人工测试的时间。

在之前的内容中，我讲述了我负责的一个没有测试的应用。其中的一个问题就是每次我们想发布一个新版本我们都要花费四个小时的人工测试时间。不久之后我加入了另个一团队，技术总监决定我们应该写自动化测试。随着时间过去，我们减少了四小时的测试时间转为 20 分钟的自动化测试。

有了那一次的经验后，我总是给大型项目从开始就写自动化测试。驯服一匹刚出生的马比驯服一匹被囚禁的野马更容易。本书中，从一个应用的开始，你将学会创建一个顺从的应用通过写测试。

自动化测试用来测试你的应用是否正常工作是伟大的。它们用来审查代码的改变也是容易的。让我们看下一个真实的自动化测试的例子，测试 GitHub 的 pull requests。

### 测试 GitHub 的 pull request

GitHub 是一个 Git 仓库网站。很多开源项目比如 Vue 都放在了 GitHub 上，大多是公司把它们的代码放在了 GitHub 私有仓库中。

::: tip Git
Git 是一个版本控制系统。我假设你之前用过了比如合并、分支和提交等功能。如果你没有，请先去看 Git 文档：[https://git-scm.com](https://git-scm.com)
:::

Pull Requests 是 GitHub 工作流的一部分。它们给了开发者机会在合并到 master 分支前，在分别的分支上审查代码。

::: tip 提示
如果你不熟悉 GitHub 工作流，阅读并理解 GitHub Flow —— [https://guides.github.com/introduction/flow](https://guides.github.com/introduction/flow)。
:::

没有测试，当你审查一个 pull request 时，你需要把代码拉取到你的机器上，运行应用，人工地测试验证它是否仍能工作。这是非常费时的，你不会对有些人会忽略整个 pull requsets 审查过程感到惊讶。

自动化测试使整个过程变得简单。当你项目中有自动化测试，你能往 pull request 的分支上安装服务，运行测试，它将会报告你测试是否通过如图1.1。只要你信任这些测试，你不必在自己的机器上确认这些代码。

图 1.1：一个 pull request 通过了测试；一个绿色勾会出现当测试通过时。

![图 1.1](https://raw.githubusercontent.com/shenxiang11/picgo/master/01fig01.jpg)

::: tip 提示
当添加了新的功能时，大多数开源项目需要开发者去写新的测试。Vue 只接受包含了对新代码测试的 pull requsets。
:::

除了让 pull requests 更容易审查，自动化测试使得现代工作流变得可持续集成，持续交付。如果你对这些工作流感兴趣，你能在 Martin Fowler 的博客上读到（[http://mng.bz/nxVK](http://mng.bz/nxVK)）。

现在我定义了自动化测试和人工测试，是时候去了解更多细节了。下一部分就是自动化测试综述，以及如何在你的应用中使用它们来测试。

::: tip 提示
是时候把自动化测试简称为测试了。从现在开始，我倾向于简称自动化测试为测试。
:::

## 测试综述

到这里，我讲述了关于测试的重要性。现在是时候讨论一下你能写的几种类型的测试。本书中，你将学习三种测试，前端应用单元测试、快照测试和端到端测试。

### 端到端测试综述

端对端测试是最符合直觉理解的一种测试类型。在前端应用中，端对端测试从用户的角度，自动操作一个浏览器来检查应用是否正确执行。

想象你正在写一个计算器应用，并你想测试两个数相加是否正确。你写的端对端测试应该是打开一个浏览器，加载计算器应用，按下 1 按钮，按下 + 按钮，再次按下 1 按钮，按下 = 按钮，最后检查屏幕上是否输出正确的结果 2。你能在下方的代码中看到这个例子也许长什么样。

清单 1.1：一个检查计算器两数相加的端对端测试
```javascript
function testCalculator(browser) {
  browser
    .url('http://localhost:8080') // 在浏览器中打开本地应用
    .click('#button-1') // 按下计算器按钮
    .click('#button-plus')
    .click('#button-1')
    .click('#button-equal')
    .assert.containsText("#result", "2") // 断言计算器输出的正确结果
    .end();
}
```

端对端测试非常地节省时间。在你写了端对端测试后，你可以执行任意次。可以想象这能够节省多少时间！

起初，端对端测试似乎是你需要的唯一工具。但是它们也有一些问题。首先，端对端测试是慢的。加载浏览器要花几秒，网站也可能响应很慢。一个端对端测试花费 30 分钟很常见，如果你完全依赖端对端测试，你的测试也要花上几个小时。

端对端测试的另一个问题是难以调试。调试一个端对端测试，你需要打开浏览器，按照用户的步骤来复现这个 bug。你的持续集成服务器上测试用例失败了，但是你的本地机器是好的，这种情况下，在本地运行端对端测试很糟糕，你会浪费不少时间。

::: tip 提示
避免再现性问题的一种方式是在可复制的环境中运行端对端测试，比如 Docker 容器。Docker 容器不属于本书的范畴，但是你可以考虑了解它，在 Docker 容器中运行端对端测试来避免不同机器上测试结果的不同。
:::

端对端测试的另一个问题是它是很脆弱的。脆弱的测试指的是即使应用测试正在工作，但是经常会失败。可能是代码执行的时间过长，或者是 API 临时性地挂了。就像一个脆弱的朋友，你会停止这个脆弱的测试。“哦，不，测试失败了！让我看看……哦，是另一个。不必担心，它永远是失败的”。脆弱的测试使测试没那么有效，但是它们在写端对端测试时，很难避免！

如果你给开发者会抱怨的问题排名，我打赌前三一定有端对端测试。它们尽管有用，但也不应是唯一的测试类型。

本书中，只有一章会专注于端对端测试，一部分因为端对端测试的缺点，另一部分因为端对端测试是框架无关的，不论你的应用是 Vue 还是 MooTools 写的。

端对端测试自动化了几种你人工会做的测试。你可以给网站每隔一段时间运行测试，或者在代码合并到 master 分支之前运行。

端对端测试并没有给你测试代码的新方法，你只是手动测试地更快了。而单元测试，是一个新的工具，你不用手动地测试代码。

### 单元测试综述

单元测试是对应用最小可执行部分（单元）的测试的过程。通常你测试的单元是函数，但是在 Vue 应用中，组件也是要测试的单元（稍后会详细介绍）。

还记得计算器应用吗？在代码中，使用了 sum 函数来计算两数之和。

如果你为了易读性而修改了代码，你会想测试代码是否还能正常运行。你可以运行一个端对端测试，但是如果端对端测试失败了，你不知道是 sum 方法出错了，还是程序其他部分出错了。唯一的方式知道 sum 函数是否出错就是独立运行它。单元测试就能做到。

单元测试就是独立地运行函数，并断言函数的正确行为。看一下下方的清单。这是一个简单的程序，引入了 sum 函数，运行它，在和不为 2 的情况下会抛出一个错误。

清单 1.2：一个基础的单元测试
```javascript
// sum.js
export default function sum(a, b) { // 要测试的函数
  return a + b
}

// sum.spec.js
import sum from '../sum' // 向测试文件倒入函数

function testSum() {
  if (sum(1,1) !== 2) {
    throw new Error('sum(1,1) did not return 2') // 结果不为 2 时，会抛出错误
  }
}

testSum() // 运行测试
```

因为单元测试是独立运行的单元，当写好的单元测试运行失败，它能像霓虹灯一样，直接指示你到代码错误的地方。

不像端对端测试，单元测试是快速的。它们几秒钟就能运行完，所以你能够每次改代码都运行来得到一个快速的反馈，来验证这些改动是否破坏了原本的功能。

单元测试的一个好的作用是它像提供了“使用文档”一样。一个新开发者接手一个项目，需要知道单元测试的行为，他们能够看单元测试准确知道一个单元是如何执行的。

我先前说过端对端测试的脆弱，即使应用能正确运行，测试经常会失败。写的好的单元测试不会遇到这种问题。只要单元测试确定了，运行一千次，每一次都是成功的。

到这里，我只说了单元测试好的方面，我可能会让它“脸红”。但是我不想误导你。就像端对端测试一样。它们也是有问题的。

单元测试的一个大问题是重构代码困难。人们通常不谈论这个问题，但是这是我一直碰到的问题。

::: tip 重构
重构就是重写代码的过程。通常是为了改善代码质量（还是由重构代码的人决定质量）。
:::

如果你想拆分一个有单元测试的复杂代码为两个独立的函数，你需要同时改代码和测试。这使得重构没有那么让人感兴趣了。有时，我会不愿意改变我代码的结构，因为它会花费我额外不少时间来更新测试。这里没有一个简单的解决方案，你需要额外考虑单元测试是否从长期的角度来说节省了你的时间。

单元测试的另一个问题是它们只检查应用独立的部分。你可以测试汽车的独立部件是否正确，但是你不知道它们组合在一起是否有用，你的测试是无效的。单元测试有这个问题。它们确保代码的最小单元按照预期执行，但是它们不会测试单元之间的互相影响。这就是为什么你需要用端对端测试来弥补单元测试。

到这里，我给你介绍了端对端测试和单元测试。你在本书学的最后一个测试叫作快照测试。

### 快照测试

你玩过《一起来找茬》吗？《一起来找茬》是从两幅很像的图中找出很小不同的游戏。游戏的目标是识别出不同。

快照测试和《一起来找茬》很像。快照测试在你运行的应用中拍了照，和之前的一次照片做对比。如果快照不同，那测试就算失败了。这种测试方法是用来检测代码变更后应用是否依然正确渲染非常有用的方式。

传统的快照测试在浏览器中启动应用，然后在渲染后的页面上截屏。与上次保存的截屏如果有不同会展示出错误。这种测试方式不同操作系统、不同浏览器版本中会出现问题，导致测试失败，即使快照没有改变。

在本书中，我会教你如何用 Jest 测试框架写快照测试。替代比对截图，Jest 快照测试比对的是 Javascript 可序列化的值。你能够用它来比对 Vue 组件的 DOM 输出。你会在第 12 章详细学习快照测试。

::: tip 可序列化
可序列化指任何可以被转化为字符串还能被转换会值的代码。实际上，它指的是 V8 方法，你不必再深入了解。
:::

现在你知道了你将要写的每一种测试。是时候来说说如何来组合这些测试方法来进行有效的测试。

### 有效地组合几种测试

如果你把糖、面粉和黄油按正确的量混合，你会得到一个做美味饼干的面团。如果你的量不正确，你会得到一个粉状的牛奶。你需要按正确的量来混合不同的测试方法来确保你的测试是健壮的而不是混乱的测试代码。

在图 1.2 中你会啊看到前端测试金字塔。它代表着前端测试中，不同测试正确的比例。从我的经验来说，这是测试 Vue 应用最好的测试结构。

图 1.2 测试金字塔。最多的测试应该是单元测试。

![图 1.2](https://raw.githubusercontent.com/shenxiang11/picgo/master/01fig02_alt.jpg)

金字塔构成最多的是单元测试，它们在开发中提供了快速的反馈。快照测试运行也非常快，但是它们比单元测试覆盖更多，所以你不需要太多快照测试。

就像我之前说的，端对端测试测试应用是很棒的，但是它是很慢而且脆弱的。最好避免脆弱的测试的方式是不写，所以这个前端测试金字塔只有一些端对端测试。

::: warning 没有集成测试
如果你是一个有经验的开发者，你也许听说过集成测试。集成测试是另一种测试类型，通常混合了单元测试和端对端测试。

我不推荐给前端代码写集成测试。在前端范畴，集成测试很难定义、很难写、很难调试。

不同的人对集成测试的定义不同，尤其是在前端。有些人认为跑在浏览器环境中是集成测试。一些人认为以模块依赖运行一个单元是集成测试。一些人认为完全渲染一个组件是集成测试。

在第 13 章中，我会教你如何写服务端集成测试（根据我自己的定义），来确保 Http 请求正确响应。但是这本书中的前端测试，不会写任何集成测试。
:::

这本书中，你会按照前端测试金字塔来写测试。我将会教你一个测试驱动的开发工作流。为了理解本书中代码的组织，你需要理解测试驱动的开发工作流程。

### 测试驱动开发

测试驱动（TDD）是在你写代码前，先写一个会失败的测试。在你写组件代码前，你要写测试来确保组件行为正确。

流行的 TDD 目标是红、绿、重构。红、绿、重构指的是写一个会失败的测试（红），然后使它测试通过（绿），最后重构代码使代码更易读。

像这样开发应用有不少好处。首先，你写的代码是函数型的通过测试的，这确保了代码的精小。其次，它强迫你在写代码前想好组件如何设计。

::: tip 提示
我声明 TDD 并不适合每一个人，我不会向你推销它。你不必因为本书用了 TDD，而在你的项目中也使用 TDD。在本书中，我使用 TDD 的主要原因是它会优先展示测试代码，然后是源代码，因为在本书中，测试代码比源代码重要。
:::

TDD 有非常多的风格，香草味、柠檬味、樱桃味、橘子味。我在开玩笑，但是使用 TDD 有不同的方式。本书中用的是一个专注前端的 TDD 版本。

一些 TDD 倡导者在写源代码前写完所有的测试代码。我不会严格遵循 TDD。我在源代码前先写单元测试，但是我会在代码写完后才加入快照测试和端对端测试。我写 Vue 组件遵循下面的步骤：

1. 决定我需要的组件
2. 给每个组件写单元测试和源代码
3. 写组件样式
4. 写完的组件写快照测试
5. 在浏览器中人工检查代码
6. 写端对端测试

在实际中，有时我不会给所有的组件写单元测试，有时我也会先写组件代码再写单元测试。TDD 倡导者可能会对此一脸厌恶，但是我发现严格的 TDD 会减慢开发。

一句俗话是这么说的：***重要的是旅途的风景而不是终点***。尽管现实中它是正确的，但是在开发中，那是完全相反的。只要你写的有价值的测试节省了你的时间，你怎么写的就是完全不相干的了。

本书的大部分，我教你你将要测试什么，展示给你看测试代码，然后给你看源代码，最后测试通过。如果你跟着写代码，注意在添加源代码之前，测试会失败。

到这里，我已经告诉你了自动化测试的好处，在你激动地开始学习前，我得告诉你，自动化测试不是总是有必要的。


### 学会什么时候不测试

当我开始写自动化测试时，我想给所有东西写单元测试。我直接地了解了，未测试应用地痛点，就像一个宿醉地中年男子决定再也不碰酒了。但是现在我得到了另一个教训。***测试降低了开发效率。***

当你写测试时，你要时刻记住你写测试的理由。通常，***测试的目的是节省时间***。如果你的项目已经稳定，还会开发很长时间，进行测试会有红利。

如果测试比你节省的时间花费了更多的时间去写和维护，那你更本不应该写。当然，在编码前，很难知道你的代码在写测试的情况下会节省多少时间（随着时间推移，你会学到。），但是，举个例子，如果你是在写一个原型、或者是一个短期的项目、或者是在给创业公司做一个简单想法的项目，你也许不会从写测试上获得好处。

即使一个项目从测试中获得了好处，但是需要的测试没有你想象的那么多。让我告诉你 100% 代码覆盖率的谬论。

### 100% 代码覆盖率的谬论

代码覆盖率是用来测量你的代码库中有多少行被自动化测试覆盖了。通常代码覆盖率的测量单位是百分比：100% 的测试覆盖率意味着单元测试运行时，每一行的代码都运行了。0% 的测试覆盖率意味着没有一行代码被执行。这是有趣的测量方式，但也会带来可怕的后果。

测试提供了递减的回报。就像去健身房，当你去健身房初期，你的肌肉会增长非常快。你会在几个月内，每周只在健身房花三个小时，你的啤酒肚就会消失，看上去很健美。但是你变得越健壮，你就需要更多的时间来变得更强壮。你在健身房花的时间越多，每小时你获得的收益时在减少的。

这个的原理是和测试相同的。几小时内，你就能写出简单的测试覆盖应用的主要功能。在这之后，提升你的代码覆盖率会变得更加困难。如果你的目标是 100%（对于一些开发者是神圣的目标），这就像是从毛巾里挤出最后一滴水。这是非常困难的。

通常情况下，不要以 100% 的测试覆盖率为目标。当然，如果你是在做一个至关重要的支付应用，bug 可能会导致损失数百万，那 100% 的测试覆盖率会使你受益。

在过去几年中，我的项目有 0%、100%、和在它们直接的测试覆盖率。0% 测试覆盖率的项目使开发很挣扎。但是 100% 测试覆盖率的项目使开发效率降低，就像鼻涕虫爬沙丘一样痛苦。

达到传说中的 100% 测试覆盖率不仅仅是费时的，即使 100% 覆盖率的代码也不能保证项目没有 bug。有时你会作出错误的设想。也许你的测试代码调用了 API，而且你假定了 API 永远不会返回错误；当 API 在生产环境中返回了错误，你的应用会崩溃。

每个应用都努力达到 100% 的测试覆盖率，你也不会成为测试大师。就像是一个优秀的综合格斗家知道如何避免一场打斗，一个优秀的测试大师知道什么时候写测试，什么时候不写。

在下一章中，你会从 Hack News 应用开始写你的第一个测试用例。在此之前，我想给你介绍一下 Hack News 应用。

## Hack News 应用

当我第一次学习测试前端应用时，教程都是教我去测试一些小的应用。这对于学习技术是非常有用的，但是它们解决不了我测试真实应用时我遇到的问题。本书中，我将会从头到尾教你测试一个应用，你将要对一个真实的克隆版的 Hacker News 做测试。

图 1.3：Hacker News 网站

![图 1.3](https://raw.githubusercontent.com/shenxiang11/picgo/master/01fig03_alt.jpg)

Hacker News 是一个社交新闻网站。它有一些动态的功能，比如新增故事、查看博客和找工作板块（图 1.3）。用户可以投赞成或不喜欢来影响一个帖子的分数。如果你使用过 Reddit，你会对这个概念很熟悉。

::: tip 提示
最好的了解 Hack News 的方式是你自己去访问，[https://news.ycombinator.com/](https://news.ycombinator.com/)。
:::

本书中，你不会去实现这个投票系统。这超出了测试 Vue 应用的范围。你要做的是利用 Hack News API 创建一个展示列表项、评论和用户档案的应用。

Hack News 克隆版使用 Vue 来写视图部分，Vuex 管理状态，Vue Router 负责客户端路由。不必担心之前没有用过 Vuex 和 Vue Router。我会在后面覆盖地讲解到他们。

Hacker News 克隆版是教你 Vue 应用测试足够好的应用。它足够复杂，能让你学习测试技术，它也足够简单，不让你陷入设计的细节。

现在你知道了你要构建什么项目了，现在是时候谈论下 Vue 了。作为一本测试 Vue 的书，到这里没有提到它，已经算是讲了很久了。

## Vue 测试综述

本书讨论的是 ***测试*** Vue 应用，而不是 ***开发*** Vue 应用。我不会教你从零开始用 Vue。如果你完全是一个没有 Vue 使用经验的新手，如果你想学会本书的大部分内容，你应该在本书之外额外花时间学习 Vue 的基础。

::: tip 提示
从零学习 Vue，我推荐 Erik Hanchett 和 Benjamin Listwon 的《Vue.js in Action 》（Manning, 2018, [, www.manning.com/
books/vue-js-in-action](, www.manning.com/
books/vue-js-in-action)）。或者，Vue 的文档也是我见过最棒的文档之一，你可以去看[https://vuejs.org/v2/guide](https://vuejs.org/v2/guide)。
:::

也就是说，这本书从头到尾，我会简短地说明 Vue 地特性，会给你链接资源去学习，你可以在你需要的情况下深入学习。本书有两个章节主要是学习关于 Vuex 和 Vue Router 更复杂的话题。

尽管我不会手把手教你 Vue，但是在下一章节之前，我会教你 Vue 的基本概念，来确保我们说的是同一种语言。下面你学到的第一个词汇是 ***Vue 实例*** 。

### Vue 实例

Vue 应用是有 Vue 实例组成的。每个应用包含至少一个 Vue 实例，当你测试这个组件时，你会在测试下为这个组件创建一个 Vue 实例。

在清单 1.3 中，你会看到一个简单的 Vue 应用例子。启动这个应用，你通过一些选项对象创建了一个 ***新*** 的 Vue 实例。Vue 使用 el 选项来查找 template 要挂在的 DOM 节点。

::: tip 提示
我要假定你很熟悉 DOM 的概念。如果你不熟悉，你能从 MDN 的网站上获取它的介绍（[(http://
mng.bz/k5iQ]((http://
mng.bz/k5iQ)）。
:::

清单 1.3：创建一个 Vue 实例

```javascript
new Vue({
  el: '#app', // 选择器，决定渲染内容挂载的 DOM 元素
  template: '<div>{{message}}</div>', // 生成 DOM 节点的模版字符串
  data() {
    return {
      message: 'Hello Vue.js!' // 模版中使用到的数据
    }
  }
})
```

创建 Vue 实例值得是生成 DOM 节点也叫挂载一个实例。如果你之前写过 Vue 应用，你会在运行 Vue 应用时挂载一个 Vue 实例。

::: tip 提示
如果你仍然对 Vue 实例感到困惑，你可以去阅读下官方文档（[https://vuejs.org/v2/guide/instance.html](https://vuejs.org/v2/guide/instance.html)）。
:::

清单 1.3 中的例子，用了模版字符串来描述 Vue 应该生成的 DOM 节点。还可以有其他的方式描述这个 DOM 节点，让我们来看一看。

### templates 和 render 函数

Vue 提供了我们声明式地渲染 DOM 的方式。就是说，你可以描述一个 Vue 应该渲染的 DOM 节点的样子。

描述一个 DOM 节点有两种方式：templates 和 render 函数。Templates 使用 HTML 语法来描述 DOM，如下面代码所示。

清单 1.4：一个模版字符串

```javascript
new Vue({
  // ..
  template: '<div>{{message}}</div>',
  //
 ..
})

```

Vue 为了从 template 生成 DOM，它需要把模版转换成 ***render 函数***，也被叫作 ***编译*** 模版。就像下面的清单展示的，你能直接在 Vue 的选项中使用 render 函数来替代模版字符串。

清单 1.5：使用 render 函数

```javascript
new Vue({
  // ..
  render(createElement) {
    return createElement('div', this.message)
  },
  // ..
})
```

Vue 使用 render 函数来生成 virtual DOM ——使用 Javscript 来描述一个真实 DOM，如下方代码所示。它会对比 virtual DOM 和真实的 DOM，会更新真实 DOM 来匹配 virtual DOM。

清单 1.6：

```javascript
{
  tag: 'div',
  children: [
    {
      text: 'Hello Vue.js'
    }
  ]
}
```

:::tip 提示
如果你想了解更多关于 render 函数和 virtual DOM，你能够在 Vue 文档中了解[http://mng.bz/dP7N](http://mng.bz/dP7N)，[http://mng.bz/VqwP](http://mng.bz/VqwP)。
:::

render 函数比模版语法难读。在大多数组件中，你应该使用模版语法，但是即使你这么做，你也要知道 Vue 需要把模版语法转换成为 render 函数。

模版语法使得代码更易读，但是大的模版也可以是很难理解的。Vue 拥有组件系统，你能把组件分成独立的自包含的单元，这可以使得代码更易读和可维护。本书的大部分内容是关于组件单元测试，所以你需要好好理解什么是 Vue 组件。

### 理解 Vue 组件系统

组件是自包含的模块，由你用 Vue 模版语法写的代码。它们提取了逻辑，使得模版更加易读。如果你用过像 React 和 Angular 的前端框架，你会对组件的概念很熟悉。如果不是，你可以把组件想象成应用构建的一个模块。对于大型 Vue 应用而言，可能全是由组件组成的。

最简单的方式给你解释组件就是给你展示一些代码。你会在下面的代码中看到，```<custom-title>``` 组件的例子。注意只有注册了组件，你才能像 HTML 标签一样使用它。


清单 1.7：在 Vue 中全局注册组件

```javascript
// JavaScript
Vue.component('hello-vue', { // 定义 hello-vue 组件
  template: '<div>Hello Vue.js!</div>'
})

// HTML
  <div>
   <hello-vue /> // 在模版中使用 hello-vue
  </div>
```

你可以个用几种不同的方式定义 Vue，但是本书中会使用单文件组件的方式（SFCS）。

:::tip 提示
本书中所有定义 Vue 组件的方式都是正确的。
:::

Vue SFC 文件的后缀名是.vue。SFC 可以包含一个 ```<template>``` （与模版字符串类似），一个```<script>``` ，和```<style>```和其他自定义块 （见清单 1.8）；

:::tip 提示
本书中不会有任何自定义块，但是你可以在 vue-loader 文档中了解，[ http://mng.bz/xJBW]( http://mng.bz/xJBW)。
:::

```<script>``` 中导出的对象被称为 ***组件选项对象***。它接受的大部分选项根 Vue 实例都能获取。

清单 1.8：单文件组件（SFC）

```vue
<template>  <!--template 块-->
  <div>{{message}}</div>
</template>

<script> // script 块
  export default { // 组件选项对象
    data: {
      message: 'Hello Vue.js!'
    }
  }
</script>

<style> /* style 块 */
  div {
    color: red;
  }
</style>
```

SFC 是非法的 Javascript 和 HTML。你不能在浏览器中运行它们，所以在发送给客户端前，你需要编译 SFC。

一个编译后的 SFC 变成了 Javascript 对象，模版被转换成了 render 函数。你能在下面看到这个例子。

清单 1.9：编译后的 SFC

```javascript
Module.exports = default {
 render() { // 生成的 render 函数
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c('p', [_vm._v("I'm a template")])
  },
  name: 'example-template'
}
```

我希望这代码没有吓到你。编译后的 SFC 并不是设计成给人类可读的。你不必关注编译后的 render 函数；这是 Vue 框架的工作。只要知道 SFC 被编译成了包含 render 函数的对象。

它提供了测试组件的好的想法。

### 组件单元测试

决定写什么测试是很重要的。如果你给组件的每一个属性写测试，你会降低你的开发速度，并且测试是效率低下的。

决定给组件的哪个部分写单元测试的一个方法是 ***组件约定***的概念。组件约定指的是组件与应用其他部分的关联。

当你进入新公司工作时，会和你的老板签订合同。你会每周工作 40 小时来换取工资。因为你同意工作 40 小时作为合同的一部分，你的老板很放心的确保你会有 40 小时工作的成果，只要他支付给你工资。

同样地，当你为一个应用写组件时，应该约定好这个组件的行为。其他组件就能确保这个组件能够完成它约定好的功能，确保在正确地输入情况下会有约定好的输出。

理解输入输入对组件约定很重要。一个好的单元测试能够在触发一个输入时断言出组件生成的正确输入（图 1.4）。应该以一个使用组件但是不知道组件功能是如何实现的开发者的视角去写测试。

对于组件，一个常见的输入就是用户行为，比如用户点击了一个按钮。常见的输出是 render 函数生成的 DOM 节点，但是 Vue 中存在大量其他的输入和输出。比如：输入可能是

- 组件 props
- 用户操作（比如点击按钮）
- Vue events
- Vuex store 中的数据

Vue 组件输出的形式应该是

- Emitted events
- 外部的方法被调用

:::tip 提示
不用担心不知道 Emitted events 或 Vuex store 中的数据是什么。你将会在后面学到。
:::

图 1.4：触发一个输入断言组件输出的单元测试

![图 1.4](https://raw.githubusercontent.com/shenxiang11/picgo/master/01fig04.jpg)

想象你有一个 ```AuthorizedStatus``` 组件，```AuthorizedStatus``` 接收一个 ```authorized``` 属性。如果 ```authorized``` 是 ```true``` ，它会在一个 ```<div>``` 元素中渲染 "you’re authorized"。如果是 ```false```，会渲染 "you’re not authorized"。

:::tip 提示
属性指的是传递给组件的数据。属性是父组件子组件传递数据的方式。你可以在 Vue 文档中阅读更多，[http://mng.bz/A2Dz](http://mng.bz/A2Dz)。
:::

接下来你会看到 ```AuthorizedMessage``` 组件。

清单 1.10： AuthorizedMessage.vue

```vue
<template>
  <div>
    {{authorized ? 'you're authorized' : 'you're not authorized'}} <!-- 按条件渲染文案 -->
  <div>
</template>

<script>
  export default = {
    name: 'loader',
    props: ['authorized'] // 一个属性声明
  }
</script>
```

当你在应用中使用时，你期望它输出 "you’re authorized"，如果你传递给了它 ```authorized``` 的值为 ```true```。如果 ```authorized``` 的值为 ```false```，你应当期望它输出 "you’re not authorized"。这就是组件的约定，也是你单元测试要测的功能。本书中也会使用组件约定的方式来写单元测试。

现在你大致知道了测试的概念，你正在成为测试大师的路上。下一章，你会创建一个测试脚本并开始写第一个测试用例！

## 总结

- 两种测试类型：自动化测试、人工测试。
- 前端测试应当符合前端测试金字塔，由单元测试、快照测试和端对端测试组成。
- 测试并不是总是有受益。如果测试不能节省你的时间，那它就没有写的价值。
- Vue 应用由 Vue 实例组成，使用模版字符串或者 render 函数来描述 DOM。
- 单文件组件编译成含有 render 函数的对象。
- 使用组件约定的方式来决定组件要写什么测试。
